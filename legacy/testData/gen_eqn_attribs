#! /usr/bin/env python
"""
Program for generating large attribute files with randomly generated equations.
"""
import sys, random, urllib


#
# FuncDesc -- a function descriptor
#
class FuncDesc:
    def __init__(self, func_name, arity):
        if not isinstance(func_name, str):
            raise TypeError("func_name must be a string!")
        if not isinstance(arity, int):
            raise TypeError("arity must be an int!")
        self.func_name = func_name
        self.arity     = arity

    def getFuncName(self):
        return self.func_name

    def getArity(self):
        return self.arity

# Table of functions
functions = [
    FuncDesc("LN", 1),
    FuncDesc("EXP", 1),
    FuncDesc("MOD", 2),
    FuncDesc("SQRT", 1),
    FuncDesc("PI", 0)
]


# Table of operators
operators = [
    "+",
    "-",
    "*",
    "/",
    "^"
]


def GenerateNonnegativeFloat():
    return str(1.1 + random.random())


def GenerateRandomFunctionCall():
    func_desc = functions[random.randint(0, len(functions) - 1)]
    func_call = func_desc.getFuncName() + "("
    arity = func_desc.getArity()
    for arg_no in range(arity):
        if arg_no > 0 and arg_no < arity:
            func_call += ","
        func_call += GenerateNonnegativeFloat()
    func_call += ")"

    return func_call


def GetRandomOperator():
    return operators[random.randint(0, len(operators) - 1)]


def GenerateEquation(number_of_function_calls, number_of_operators, attrib_refs):
    no_of_terms = max(number_of_function_calls, number_of_operators)
    equation = ""
    for term_no in range(no_of_terms):
        if term_no < number_of_function_calls:
            equation += GenerateRandomFunctionCall()
        else:
            index = random.randint(0, len(attrib_refs))
            if index < len(attrib_refs):
                equation += "${" + attrib_refs[index] + "}"
            else:
                equation += GenerateNonnegativeFloat()
        if term_no < no_of_terms - 1:
            equation += GetRandomOperator()

    return "MIN(100.0, MAX(-100.0, " + equation + "))"


def GenerateLine(line_number, number_of_function_calls, number_of_operators, attrib_refs):
    print "N" + str(line_number) + " = =" + urllib.quote_plus(GenerateEquation(number_of_function_calls, number_of_operators, attrib_refs))


def Usage():
    print >> sys.stderr, "usage: " + sys.argv[0] + " attribute_name number_of_function_calls number_of_operators number_of_lines [ref=attrib1 ref=attrib2 ...]> output_file"
    sys.exit(1)


def ProcessArgs(argv):
    if len(argv) < 5:
        Usage()
    try:
        attribute_name           = argv[1]
        number_of_function_calls = int(argv[2])
        number_of_operators      = int(argv[3])
        number_of_lines          = int(argv[4])
    except ValueError:
        Usage()

    if number_of_function_calls < 0 or number_of_operators < 0 or number_of_lines < 1:
        Usage()

    # Collect references to other attributes:
    attrib_refs = []
    for arg_no in range(5, len(argv)):
        if argv[arg_no][:4] != "ref=":
            Usage();
        attrib_refs.append(argv[arg_no][4:])

    return (attribute_name, number_of_function_calls, number_of_operators, number_of_lines, attrib_refs)


#
# Start of main program!
#

(attribute_name, number_of_function_calls, number_of_operators, number_of_lines, attrib_refs) = ProcessArgs(sys.argv)
print attribute_name + " (class=java.lang.Double)"

for i in range(number_of_lines):
    GenerateLine(i + 1, number_of_function_calls, number_of_operators, attrib_refs)
