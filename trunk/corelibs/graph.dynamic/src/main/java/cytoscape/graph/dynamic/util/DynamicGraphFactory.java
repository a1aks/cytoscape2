
/*
 Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)

 The Cytoscape Consortium is:
 - Institute for Systems Biology
 - University of California San Diego
 - Memorial Sloan-Kettering Cancer Center
 - Institut Pasteur
 - Agilent Technologies

 This library is free software; you can redistribute it and/or modify it
 under the terms of the GNU Lesser General Public License as published
 by the Free Software Foundation; either version 2.1 of the License, or
 any later version.

 This library is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
 MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
 documentation provided hereunder is on an "as is" basis, and the
 Institute for Systems Biology and the Whitehead Institute
 have no obligations to provide maintenance, support,
 updates, enhancements or modifications.  In no event shall the
 Institute for Systems Biology and the Whitehead Institute
 be liable to any party for direct, indirect, special,
 incidental or consequential damages, including lost profits, arising
 out of the use of this software and its documentation, even if the
 Institute for Systems Biology and the Whitehead Institute
 have been advised of the possibility of such damage.  See
 the GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with this library; if not, write to the Free Software Foundation,
 Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
*/

package cytoscape.graph.dynamic.util;

import cytoscape.graph.dynamic.DynamicGraph;


/**
 * A factory for getting cytoscape.graph.dynamic.DynamicGraph instances.
 * This DynamicGraph implementation requires a bare minimum of roughly 64
 * megabytes for a graph with one million edges and one hundred thousand nodes.
 * That is, the memory requirements are roughly 64 bytes per node and edge.<p>
 *
 * Nodes and edges created by the returned DynamicGraph are strictly less
 * than Integer.MAX_VALUE.  This implementation of DynamicGraph has been
 * coded to assume that graphs containing Integer.MAX_VALUE number of nodes and
 * Integer.MAX_VALUE number of edges will be created; however, due to lack of
 * sufficient memory in available hardware, such large graphs have not [yet]
 * been tested using this implementation.<p>
 *
 * This implementation of DynamicGraph creates nodes and edges
 * with small integer values.  This implementation re-uses node and edge
 * values as nodes and edges are removed and added.  Thus, nodes and edges
 * will not take ever-increasing values if they are continually being
 * removed and added.<p>
 *
 * The returned DynamicGraph does not free up memory.  That is, if a
 * DynamicGraph contains one million edges and one hundred thousand nodes,
 * it consumes roughly 64 megabytes.  If all nodes and edges are then removed
 * from the DynamicGraph, it will still consume roughly 64 megabytes of
 * memory.  If one hundred thousand nodes and one million edges are
 * then created, the DynamicGraph will still consume roughly 64 megabytes of
 * memory.  If all nodes and edges are removed and then re-created, repeatedly
 * over an infinite number of iterations, the overall memory consumption
 * required by this DynamicGraph will remain constant.<p>
 *
 * The DynamicGraph instances generated by this factory implement the
 * java.io.Serializable interface.  However, do not use the serialization
 * facility to store graphs in a persistent manner because the serialization
 * in this graph implementation does not handle versioning; if the class
 * structure of the graph implementation changes (due to bug fixes or
 * performance optimizations, for example), graphs serialized and saved from
 * the old class definition will fail to be loaded by the new class
 * definition.<p>
 *
 * Below are time complexities of DynamicGraph methods:
 * <blockquote><table border=1 cellspacing=0 cellpadding=5>
 * <tr><th>DynamicGraph method</th><th>time complexity</th></tr>
 * <tr>
 * <td>nodes()</td>
 * <td>An IntEnumerator is returned in constant time.  The enumerator
 *     returns each successive element in constant time.  The enumerator
 *     reports the number of elements remaining in constant time.</td>
 * </tr><tr>
 * <td>edges()</td>
 * <td>An IntEnumerator is returned in constant time.  The enumerator
 *     returns each successive element in constant time.  The enumerator
 *     reports the number of elements remaining in constant time.</td>
 * </tr><tr>
 * <td>nodeCreate()</td>
 * <td>A node is created in amortized constant time.  Amortized because
 *     doubling the size of an underlying array will be necessary as
 *     the DynamicGraph increases in its total node count.</td>
 * </tr><tr>
 * <td>nodeRemove(int)</td>
 * <td>A node is removed in O(E) time, where E is the number of
 *     edges touching the node being removed.</td>
 * </tr><tr>
 * <td>edgeCreate(int, int, boolean)</td>
 * <td>An edge is created in amortized constant time.  Amortized because
 *     doubling the size of an underlying array will be necessary as the
 *     DynamicGraph increases in its total edge count.</td>
 * </tr><tr>
 * <td>edgeRemove(int)</td>
 * <td>An edge is removed in constant time.</td>
 * </tr><tr>
 * <td>nodeExists(int)</td>
 * <td>The existence of a node is determined in constant time.</td>
 * </tr><tr>
 * <td>edgeType(int)</td>
 * <td>The existence/type of an edge is determined in constant time.</td>
 * </tr><tr>
 * <td>edgeSource(int)</td>
 * <td>The source node of an edge is determined in constant time.</td>
 * </tr><tr>
 * <td>edgeTarget(int)</td>
 * <td>The target node of an edge is determined in constant time.</td>
 * </tr><tr>
 * <td>edgesAdjacent(int, boolean, boolean, boolean)</td>
 * <td>An IntEnumerator is returned in constant time.  The enumerator
 *     always reports the number of elements remaining in constant time.
 *     The enumeration can be completely traversed in O(E) time, where E is
 *     the number of edges touching the node in question.  Each individual
 *     successive element is returned by the enumeration in average
 *     O(E/F) time, where F is the total number of elements in this
 *     enumeration.</td>
 * </tr><tr>
 * <td>edgesConnecting(int, int, boolean, boolean, boolean)</td>
 * <td>An IntIterator is returned in constant time.  The iteration can be
 *     completely traversed in O(min(E, F)) time, where E is the total number
 *     of edges touching one node and F is the total number of edges touching
 *     the other node.</td>
 * </tr></table></blockquote>
 */
public final class DynamicGraphFactory {
	// "No constructor".
	private DynamicGraphFactory() {
	}

	/**
	 * Returns a new instance of DynamicGraph with every invocation.
	 */
	public static DynamicGraph instantiateDynamicGraph() {
		return new DynamicGraphRepresentation();
	}
}
