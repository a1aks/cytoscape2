package cytoscape.data.annotation;

import giny.view.NodeView;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import cytoscape.CyNetwork;
import cytoscape.CyNode;
import cytoscape.Cytoscape;
import cytoscape.CytoscapeInit;
import cytoscape.data.CyAttributes;
import cytoscape.data.Semantics;
import cytoscape.data.annotation.AnnotationGui.Gui.SelectNodesTreeSelectionListener;
import cytoscape.data.servers.BioDataServer;
import cytoscape.view.CyNetworkView;

/*
 * OntologyMapperDialog.java
 * 
 * Created on 2006/04/11, 9:57
 * 
 * This code was created by Netbeans 5 w/Swing-Layout + Eclipse 3.1.
 * Swing-Layout class will be standard in Java Standard Edition 6.
 *
 * @author kono
 */
public class OntologyMapperDialog extends JDialog {

	protected BioDataServer dataServer;
	protected String defaultSpecies;

	private AnnotationDescription[] annotationDescriptions;
	private TreePath annotationPath;
	private String currentAnnotationCategory;

	private HashMap appliedOntologies;

	private CyNetworkView networkView;
	private CyNetwork network;

	public OntologyMapperDialog() {
		initDataStructures();
		initComponents();
	}

	/** Creates new form OntologyMapperDialog */
	public OntologyMapperDialog(java.awt.Frame parent, boolean modal) {
		super(parent, modal);
		initDataStructures();

		initComponents();
	}

	private void initDataStructures() {

		appliedOntologies = new HashMap();

		networkView = Cytoscape.getCurrentNetworkView();
		network = networkView.getNetwork();
		dataServer = Cytoscape.getBioDataServer();

		annotationDescriptions = dataServer.getAnnotationDescriptions();
		Semantics.applyNamingServices(network);

		defaultSpecies = CytoscapeInit.getProperty("defaultSpeciesName");
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed" desc=" Generated Code ">
	private void initComponents() {
		goServerScrollPane = new javax.swing.JScrollPane();
		goServerTree = new javax.swing.JTree();
		goAttributeScrollPane = new javax.swing.JScrollPane();
		goAttributeTree = new javax.swing.JTree();
		buttonPanel = new javax.swing.JPanel();
		applyButton = new javax.swing.JButton();
		removeButton = new javax.swing.JButton();
		applyAllButton = new javax.swing.JButton();
		removeAllButton = new javax.swing.JButton();
		layoutButton = new javax.swing.JButton();
		addEdgesButton = new javax.swing.JButton();
		deleteCreatedButton = new javax.swing.JButton();
		okButton = new javax.swing.JButton();
		jScrollPane3 = new javax.swing.JScrollPane();
		jList1 = new javax.swing.JList();

		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
		setTitle("Ontology Mapper");
		goServerScrollPane.setBorder(javax.swing.BorderFactory
				.createTitledBorder(null, "Onyologies in Local GO Server",
						javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
						javax.swing.border.TitledBorder.DEFAULT_POSITION,
						new java.awt.Font("Serif", 1, 12)));

		goServerTree = this.createAvailableAnnotationsTree();
		goServerTree
				.addTreeSelectionListener(new AddAnnotationTreeSelectionListener());

		goServerScrollPane.setViewportView(goServerTree);

		goAttributeTree = this.createNodeSelectionTree();
		goAttributeTree.addTreeSelectionListener(new SelectNodesTreeSelectionListener());
		
		goAttributeScrollPane.setBorder(javax.swing.BorderFactory
				.createTitledBorder(null, "GO Data as Attributes",
						javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
						javax.swing.border.TitledBorder.DEFAULT_POSITION,
						new java.awt.Font("Serif", 1, 12)));
		goAttributeScrollPane.setViewportView(goAttributeTree);

		applyButton.setFont(new java.awt.Font("Serif", 1, 12));
		applyButton.setText(">>");
		applyButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				applyButtonActionPerformed(evt);
			}
		});

		removeButton.setFont(new java.awt.Font("Serif", 1, 12));
		removeButton.setText("<<");
		removeButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				removeButtonActionPerformed(evt);
			}
		});

		applyAllButton.setText("Applly All");
		applyAllButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				applyAllButtonActionPerformed(evt);
			}
		});

		removeAllButton.setText("Remove All");

		layoutButton.setText("Layout");

		addEdgesButton.setText("Add Edges");

		deleteCreatedButton.setText("Delete Created");

		okButton.setText("OK");
		okButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				okButtonActionPerformed(evt);
			}
		});

		org.jdesktop.layout.GroupLayout buttonPanelLayout = new org.jdesktop.layout.GroupLayout(
				buttonPanel);
		buttonPanel.setLayout(buttonPanelLayout);
		buttonPanelLayout
				.setHorizontalGroup(buttonPanelLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								buttonPanelLayout
										.createSequentialGroup()
										.add(
												buttonPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.LEADING)
														.add(
																buttonPanelLayout
																		.createSequentialGroup()
																		.addContainerGap()
																		.add(
																				buttonPanelLayout
																						.createParallelGroup(
																								org.jdesktop.layout.GroupLayout.LEADING)
																						.add(
																								org.jdesktop.layout.GroupLayout.TRAILING,
																								applyButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)
																						.add(
																								org.jdesktop.layout.GroupLayout.TRAILING,
																								applyAllButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)))
														.add(
																buttonPanelLayout
																		.createSequentialGroup()
																		.add(
																				45,
																				45,
																				45)
																		.add(
																				okButton)))
										.addContainerGap()));

		buttonPanelLayout.setVerticalGroup(buttonPanelLayout
				.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
				.add(
						org.jdesktop.layout.GroupLayout.TRAILING,
						buttonPanelLayout.createSequentialGroup()
								.addContainerGap(103, Short.MAX_VALUE).add(
										applyButton).add(23, 23, 23).add(
										applyAllButton).add(123, 123, 123).add(
										okButton)));

		org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(
				getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(
				org.jdesktop.layout.GroupLayout.TRAILING,
				layout.createSequentialGroup().addContainerGap().add(
						goServerScrollPane,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 350,
						Short.MAX_VALUE).addPreferredGap(
						org.jdesktop.layout.LayoutStyle.RELATED).add(
						buttonPanel,
						org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
						org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
						org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.addPreferredGap(
								org.jdesktop.layout.LayoutStyle.RELATED).add(
								goAttributeScrollPane,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								350, Short.MAX_VALUE).addContainerGap()));
		layout.setVerticalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(
				layout.createSequentialGroup().addContainerGap().add(
						layout.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING).add(
								buttonPanel,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								Short.MAX_VALUE).add(
								org.jdesktop.layout.GroupLayout.TRAILING,
								goAttributeScrollPane,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								400, Short.MAX_VALUE).add(
								org.jdesktop.layout.GroupLayout.TRAILING,
								goServerScrollPane,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								400, Short.MAX_VALUE)).addContainerGap()));
		pack();

	}

	private void removeButtonActionPerformed(java.awt.event.ActionEvent evt) {
		// TODO add your handling code here:
	}

	private void applyAllButtonActionPerformed(java.awt.event.ActionEvent evt) {
		// TODO add your handling code here:
		
	}

	/*
	 * This method will be called by Apply Button ( >> ).
	 */
	private void applyButtonActionPerformed(java.awt.event.ActionEvent evt) {

		DefaultMutableTreeNode node1 = (DefaultMutableTreeNode) annotationPath
				.getPathComponent(1);
		AnnotationDescription aDesc = (AnnotationDescription) node1
				.getUserObject();
		DefaultMutableTreeNode node2 = (DefaultMutableTreeNode) annotationPath
				.getPathComponent(2);

		int level = ((Integer) node2.getUserObject()).intValue();
		if (aDesc == null)
			return;

		currentAnnotationCategory = addAnnotationToNodes(aDesc, level);

		Object[] uniqueAnnotationValues = null;

		CyAttributes nodeAtts = Cytoscape.getNodeAttributes();
		Iterator it = Cytoscape.getRootGraph().nodesIterator();
		HashSet values = new HashSet();
		while (it.hasNext()) {
			CyNode node = (CyNode) it.next();
			byte type = nodeAtts.getType(currentAnnotationCategory);
			if (type == CyAttributes.TYPE_STRING) {
				String strVal = nodeAtts.getStringAttribute(node
						.getIdentifier(), currentAnnotationCategory);
				if (strVal != null)
					values.add(strVal);
			} else if (type == CyAttributes.TYPE_SIMPLE_LIST) {
				List vals = nodeAtts.getAttributeList(node.getIdentifier(),
						currentAnnotationCategory);
				if (vals.size() > 0) {
					Object val = vals.get(0);
					if (val instanceof String)
						values.addAll(vals);
				}
			}

		}// while it.hasNext

		uniqueAnnotationValues = values.toArray();

		if (uniqueAnnotationValues.length == 0) {
			// System.err.println( "No match exception" + e1 );
			JOptionPane
					.showMessageDialog(
							null,
							"There is no match between the selected annotation \n"
									+ "and current nodes in the network.\n"
									+ "\nMake sure that your network data file \n"
									+ "and Gene Association files use same naming scheme.\n\n"
									+ "Please compare the 3rd column of Gene Association\n"
									+ "file (DB_Object_Symbol) and node names in your network.",
							"No match in Gene Ontology Database",
							JOptionPane.ERROR_MESSAGE);

		} // Mod by kono end (10/20/2005)

		if (uniqueAnnotationValues != null && uniqueAnnotationValues.length > 0
				&& uniqueAnnotationValues[0].getClass() == String.class) {
			java.util.Arrays.sort(uniqueAnnotationValues,
					(Comparator) String.CASE_INSENSITIVE_ORDER);
			appendToSelectionTree(currentAnnotationCategory,
					uniqueAnnotationValues);
		}
	}

	protected void appendToSelectionTree(String currentAnnotationCategory,
			Object[] uniqueAnnotationValues) {
		DefaultMutableTreeNode branch = new DefaultMutableTreeNode(
				currentAnnotationCategory);

		for (int i = 0; i < uniqueAnnotationValues.length; i++)
			branch.add(new DefaultMutableTreeNode(uniqueAnnotationValues[i]));

		DefaultMutableTreeNode root = (DefaultMutableTreeNode) goAttributeTree
				.getModel().getRoot();
		DefaultTreeModel model = (DefaultTreeModel) goAttributeTree.getModel();
		model.insertNodeInto(branch, root, root.getChildCount());
		goAttributeTree.scrollPathToVisible(new TreePath(branch.getPath()));
		model.reload();

	} // appendToSelectionTree

	private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {
		// TODO add your handling code here:
		this.dispose();
	}

	// Variables declaration - do not modify
	private javax.swing.JButton addEdgesButton;
	private javax.swing.JButton applyAllButton;
	private javax.swing.JButton applyButton;
	private javax.swing.JPanel buttonPanel;
	private javax.swing.JButton deleteCreatedButton;
	private javax.swing.JScrollPane goAttributeScrollPane;
	private javax.swing.JTree goAttributeTree;
	private javax.swing.JScrollPane goServerScrollPane;
	private javax.swing.JTree goServerTree;
	private javax.swing.JList jList1;
	private javax.swing.JScrollPane jScrollPane3;
	private javax.swing.JButton layoutButton;
	private javax.swing.JButton okButton;
	private javax.swing.JButton removeAllButton;
	private javax.swing.JButton removeButton;

	// End of variables declaration

	/*
	 * Build GO Server Tree
	 * 
	 * This tree is based on data in BioDataServer Object.
	 * 
	 */
	protected JTree createAvailableAnnotationsTree() {
		DefaultMutableTreeNode root = new DefaultMutableTreeNode(
				"Available Annotations");
		createTreeNodes(root, annotationDescriptions);
		JTree tree = new JTree(root);
		tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setRootVisible(false);
		tree.setShowsRootHandles(true);
		// expandAll (tree, new TreePath (root), true);
		return tree;
	}

	protected void createTreeNodes(DefaultMutableTreeNode root,
			AnnotationDescription[] descriptions)
	// for each of the descriptions, and only if the description is of a
	// species in the
	// current graph: create a 'topLevelName' which will be the branch of
	// the JTree,
	// and a set of leaves for each logical level in that description's
	// ontology
	{
		if (descriptions == null || descriptions.length == 0)
			return;

		// Extract species name in the network.
		Set speciesInGraph = Semantics.getSpeciesInNetwork(network);

		DefaultMutableTreeNode branch = null;
		Vector topLevelNamesList = new Vector();

		for (int i = 0; i < descriptions.length; i++) {
			String species = descriptions[i].getSpecies();
			if (!speciesInGraph.contains(species)) {
				continue;
			}
			topLevelNamesList.add(descriptions[i].getCurator() + ", "
					+ descriptions[i].getType() + ", "
					+ descriptions[i].getSpecies());
			branch = new DefaultMutableTreeNode(descriptions[i]);

			// Extract annotation from
			Annotation annotation = dataServer.getAnnotation(descriptions[i]);

			if (annotation == null) {
				continue;
			}
			int maxDepth = annotation.maxDepth();
			for (int level = 0; level < maxDepth; level++)
				branch.add(new DefaultMutableTreeNode(new Integer(level + 1)));
			root.add(branch);
		}

	} // createTreeNodes

	protected JTree createNodeSelectionTree() {
		DefaultMutableTreeNode root = new DefaultMutableTreeNode(
				"Annotations Categories");
		JTree tree = new JTree(root);
		// tree.getSelectionModel().setSelectionMode
		// (TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setRootVisible(false);
		tree.setShowsRootHandles(true);
		expandAll(tree, new TreePath(root), true);
		return tree;

	} // createNodeSelectionTree

	private void expandAll(JTree tree, TreePath parent, boolean expand) {
		TreeNode node = (TreeNode) parent.getLastPathComponent();
		if (node.getChildCount() >= 0) {
			for (Enumeration e = node.children(); e.hasMoreElements();) {
				TreeNode n = (TreeNode) e.nextElement();
				TreePath path = parent.pathByAddingChild(n);
				expandAll(tree, path, expand);
			} // for
		} // if

		if (expand)
			tree.expandPath(parent);
		else
			tree.collapsePath(parent);

	} // expandAll

	/*
	 * Methods called by actions
	 * 
	 */

	/*
	 * Map BDS object to CyAttributes. TODO: Support Synonym
	 * 
	 */
	public String addAnnotationToNodes(AnnotationDescription aDesc, int level) {

		CyAttributes nodeAttributes = Cytoscape.getNodeAttributes();
		// something like "GO biological process" or "KEGG metabolic pathway"
		String baseAnnotationName = aDesc.getCurator() + " " + aDesc.getType();
		String annotationNameAtLevel = baseAnnotationName + " (Level " + level
				+ ")";
		String annotationNameForLeafIDs = baseAnnotationName + " leaf IDs";

		// make a fresh start
		nodeAttributes.deleteAttribute(annotationNameAtLevel);
		nodeAttributes.deleteAttribute(annotationNameForLeafIDs);

		Iterator it = Cytoscape.getRootGraph().nodesIterator();
		ArrayList nodeLabels = new ArrayList();
		while (it.hasNext()) {
			CyNode node = (CyNode) it.next();
			// String nodeLabel = nodeAttributes.getStringAttribute(node
			// .getIdentifier(), Semantics.CANONICAL_NAME);
			String nodeLabel = node.getIdentifier();
			if (nodeLabel != null)
				nodeLabels.add(nodeLabel);
		}

		String[] nodeLabelArray = (String[]) nodeLabels
				.toArray(new String[nodeLabels.size()]);

		int unAnnotatedNodeCount = 0;
		for (int i = 0; i < nodeLabelArray.length; i++) {

			// System.out.println("Applying: " + nodeLabelArray[i] + ", aDesc =
			// " + aDesc.toString() );

			String[][] fullAnnotations = dataServer.getAllAnnotations(aDesc,
					nodeLabelArray[i]);
			if (fullAnnotations.length == 0)
				unAnnotatedNodeCount++;
			else {
				String[] uniqueAnnotationsAtLevel = collapseToUniqueAnnotationsAtLevel(
						fullAnnotations, level);

				// List to save values in the current level
				List annotsList = new ArrayList();
				if (uniqueAnnotationsAtLevel.length == 0) {
					// No attribute available for this node
					nodeAttributes.setAttribute(nodeLabelArray[i],
							annotationNameAtLevel, "");
				} else {
					// Extract all values in the current level
					for (int j = 0; j < uniqueAnnotationsAtLevel.length; j++) {

						// System.out.print("node cn = " + canonicalNodeNames[i]
						// + ", and an@level = " + annotationNameAtLevel);
						// System.out.println(", an value@level = "
						// + uniqueAnnotationsAtLevel[j]);

						// we can do this because at the begining of the method
						// we deleted the attribute annotationNameAtLevel:
						// annotsList =
						// nodeAttributes.getAttributeList(canonicalNodeNames[i],
						// annotationNameAtLevel);

						// annotsList =
						// nodeAttributes.getAttributeList(canonicalNodeNames[i],
						// annotationNameAtLevel);
						//					
						// if(annotsList == null){
						// annotsList = new ArrayList();
						// //nodeAttributes.setAttributeList(canonicalNodeNames[i],
						// annotationNameAtLevel,annotsList);
						// annotsList.add(uniqueAnnotationsAtLevel[j]);
						// }
						// System.out.println(" " +
						// uniqueAnnotationsAtLevel[j]);
						annotsList.add(uniqueAnnotationsAtLevel[j]);

					}// for j

					if (annotsList.size() != 0) {
						nodeAttributes.setAttributeList(nodeLabelArray[i],
								annotationNameAtLevel, annotsList);
					}
				}
				int[] annotationIDs = dataServer.getClassifications(aDesc,
						nodeLabelArray[i]);
				Integer[] integerArray = new Integer[annotationIDs.length];
				for (int j = 0; j < annotationIDs.length; j++)
					integerArray[j] = new Integer(annotationIDs[j]);
			} // else: this node is annotated
		} // for i

		// System.err
		// .println("Warning: a method has been called whose functionality "
		// + "has been partially removed "
		// + "(AnnotationGui.addAnnotationToNodes()).");

		// network.endActivity(callerID);

		return annotationNameAtLevel;

		// CyAttributes nodeAttributes = Cytoscape.getNodeAttributes();
		//
		// // something like "GO biological process" or "KEGG metabolic pathway"
		// String baseAnnotationName = aDesc.getCurator() + " " +
		// aDesc.getType();
		// String annotationNameAtLevel = baseAnnotationName + " (Level " +
		// level
		// + ")";
		// String annotationNameForLeafIDs = baseAnnotationName + " leaf IDs";
		//
		// // This is necessary since Thesaurus needs species name.
		// String species = aDesc.getSpecies();
		//
		// // make a fresh start
		// nodeAttributes.deleteAttribute(annotationNameAtLevel);
		// nodeAttributes.deleteAttribute(annotationNameForLeafIDs);
		//
		// Iterator it = Cytoscape.getRootGraph().nodesIterator();
		// ArrayList canonicals = new ArrayList();
		// while (it.hasNext()) {
		// CyNode node = (CyNode) it.next();
		// String canonical = nodeAttributes.getStringAttribute(node
		// .getIdentifier(), Semantics.CANONICAL_NAME);
		// if (canonical != null)
		// canonicals.add(canonical);
		// }
		//
		// String[] canonicalNodeNames = (String[]) canonicals
		// .toArray(new String[canonicals.size()]);
		//
		// int unAnnotatedNodeCount = 0;
		// for (int i = 0; i < canonicalNodeNames.length; i++) {
		// String[][] fullAnnotations = dataServer.getAllAnnotations(aDesc,
		// canonicalNodeNames[i]);
		// if (fullAnnotations.length == 0)
		// unAnnotatedNodeCount++;
		// else {
		// String[] uniqueAnnotationsAtLevel =
		// collapseToUniqueAnnotationsAtLevel(
		// fullAnnotations, level);
		//
		// // List to save values in the current level
		// List annotsList = new ArrayList();
		// if (uniqueAnnotationsAtLevel.length == 0) {
		// // No attribute available for this node
		// nodeAttributes.setAttribute(canonicalNodeNames[i],
		// annotationNameAtLevel, "");
		// } else {
		// // Extract all values in the current level
		// for (int j = 0; j < uniqueAnnotationsAtLevel.length; j++) {
		//
		// System.out.println("node cn = " + canonicalNodeNames[i]
		// + ", and an@level = " + annotationNameAtLevel);
		//
		// String[] syno = dataServer.getAllCommonNames(species,
		// canonicalNodeNames[i]);
		//
		// for (int idx = 0; idx < syno.length; idx++) {
		// System.out.println("Syno = " + syno[idx]);
		// }
		//
		// // System.out.println(", an value@level = "
		// // + uniqueAnnotationsAtLevel[j]);
		//
		// // we can do this because at the begining of the method
		// // we deleted the attribute annotationNameAtLevel:
		// annotsList = nodeAttributes.getAttributeList(
		// canonicalNodeNames[i], annotationNameAtLevel);
		//
		// // annotsList = nodeAttributes.getAttributeList(
		// // canonicalNodeNames[i], annotationNameAtLevel);
		//
		// if (annotsList == null) {
		// annotsList = new ArrayList();
		// nodeAttributes.setAttributeList(
		// canonicalNodeNames[i],
		// annotationNameAtLevel, annotsList);
		// annotsList.add(uniqueAnnotationsAtLevel[j]);
		// }
		// annotsList.add(uniqueAnnotationsAtLevel[j]);
		//
		// }// for j
		//
		// if (annotsList.size() != 0) {
		// nodeAttributes.setAttributeList(canonicalNodeNames[i],
		// annotationNameAtLevel, annotsList);
		// }
		// }
		//
		// int[] annotationIDs = dataServer.getClassifications(aDesc,
		// canonicalNodeNames[i]);
		// Integer[] integerArray = new Integer[annotationIDs.length];
		// for (int j = 0; j < annotationIDs.length; j++)
		// integerArray[j] = new Integer(annotationIDs[j]);
		// } // else: this node is annotated
		// } // for i
		//
		// return annotationNameAtLevel;

	} // addAnnotationToNodes

	/**
	 * return only the unique categories (typically representing gene
	 * annotations) which exist at the specified level. genes (for example) may
	 * be annotated as belonging to two or more different categories, but at a
	 * higher logical level, these different categories may merge. for example,
	 * the halobacterium gene VNG0623G is classified by KEGG, in its 3-level
	 * ontology as belonging to two categories at the most specific (third)
	 * level
	 * <ol>
	 * <li> Valine, leucine and isoleucine degradation
	 * <li> Propanoate metabolism
	 * <ol>
	 * At level two, the annotation is:
	 * <ol>
	 * <li> Amino Acid Metabolism
	 * <li> Carbohydrate Metabolism
	 * <ol>
	 * At level one, the annotation is simply
	 * <ol>
	 * <li>Metabolism
	 * <ol>
	 * This method calculates and returns the unique annotations for a
	 * biological entity at the specified level.
	 */
	private String[] collapseToUniqueAnnotationsAtLevel(
			String[][] fullAnnotations, int level) {
		Vector collector = new Vector();

		for (int i = 0; i < fullAnnotations.length; i++) {
			int indexOfClosestAvailableLevel = level - 1;
			if (indexOfClosestAvailableLevel > (fullAnnotations[i].length - 1))
				indexOfClosestAvailableLevel = fullAnnotations[i].length - 1;
			String annotationAtLevel = fullAnnotations[i][indexOfClosestAvailableLevel];
			if (!collector.contains(annotationAtLevel))
				collector.add(annotationAtLevel);
		} // for i

		return (String[]) collector.toArray(new String[0]);

	} // collapseToUniqueAnnotationsAtLevel

	class AddAnnotationTreeSelectionListener implements TreeSelectionListener {

		public void valueChanged(TreeSelectionEvent e) {

			DefaultMutableTreeNode node = (DefaultMutableTreeNode) goServerTree
					.getLastSelectedPathComponent();
			if (node == null)
				return;
			if (!node.isLeaf())
				return;
			annotationPath = goServerTree.getSelectionPaths()[0];
			// annotateNodesButton.setEnabled(true);
		}

	} // 
	
	
	
	/*
	 * Used for selecting nodes from GO Annotation tree.
	 */
	class SelectNodesTreeSelectionListener implements TreeSelectionListener {

		public void valueChanged(TreeSelectionEvent e) {
			DefaultMutableTreeNode node = (DefaultMutableTreeNode) goAttributeTree
					.getLastSelectedPathComponent();
			if (node == null)
				return;
			
			
			/*
			 * These functions are removed from 2.3
			 * Maybe fixed in later version...
			 */
			//layoutByAnnotationButton.setEnabled(!node.isLeaf());
			//addSharedAnnotationEdgesButton.setEnabled(!node.isLeaf());
			
			if (!node.isLeaf())
				return;

			CyAttributes nodeAttributes = Cytoscape.getNodeAttributes();

			// unselect every node in the graph
			for (Iterator nvi = networkView.getNodeViewsIterator(); nvi
					.hasNext();) {
				((NodeView) nvi.next()).setSelected(false);
			}
			TreePath[] selectedPaths = goAttributeTree
					.getSelectionPaths();
			HashMap selectionHash = extractAnnotationsFromSelection(selectedPaths);
			for (Iterator nvi = networkView.getNodeViewsIterator(); nvi
					.hasNext();) {
				// get the particular node view
				NodeView nv = (NodeView) nvi.next();
//				String nodeLabel = nodeAttributes.getStringAttribute(nv
//						.getNode().getIdentifier(),
//						Semantics.CANONICAL_NAME);
				String nodeLabel = nv.getNode().getIdentifier();
				
				if (nodeLabel == null) {
					continue;
				}
				// iterate over all attributes in the selectionHash
				for (Iterator mi = selectionHash.keySet().iterator(); mi
						.hasNext();) {
					String name = (String) mi.next();

					Vector categoryList = (Vector) selectionHash.get(name);
					byte type = nodeAttributes.getType(name);
					if (type == CyAttributes.TYPE_STRING) {
						String attributeValue = nodeAttributes
								.getStringAttribute(nodeLabel, name);
						if (attributeValue != null
								&& categoryList.contains(attributeValue))
							nv.setSelected(true);
						break; // no point in checking other attributes
					} else if (type == CyAttributes.TYPE_SIMPLE_LIST) {
						boolean hit = false;
						List attributeList = nodeAttributes
								.getAttributeList(nodeLabel, name);
						for (Iterator ali = attributeList.iterator(); ali
								.hasNext();) {
							if (categoryList.contains(ali.next())) {
								nv.setSelected(true);
								hit = true;
								break; // no point in checking the rest of
								// the list
							}
						}// ali iterator

						if (hit) {
							break;
						} // no point in checking other attributes

					}// if list
				}// mi iterator
			}// nvi iterator

			networkView.redrawGraph(false, false);

		} // valueChanged

		// -----------------------------------------------------------------------------
		/**
		 * create a hashmap, <String, String []>:
		 * 
		 * "KEGG Metabolic Pathway (level 1)" -> (Genetic Information
		 * Processing) "KEGG Metabolic Pathway (level 2)" -> (Amino Acid
		 * Metabolism, Nucleotide Metabolism)
		 * 
		 * this method is brittle, and will fail if the structure of the
		 * tree changes: it expects level 0: root level 1: a standard
		 * annotation name (see above) level 2: standard annotation category
		 * name (also see above)
		 */
		protected HashMap extractAnnotationsFromSelection(TreePath[] paths) {
			HashMap hash = new HashMap();

			for (int i = 0; i < paths.length; i++) {
				String annotationName = paths[i].getPathComponent(1)
						.toString();
				String annotationValue = paths[i].getPathComponent(2)
						.toString();
				Vector list;
				if (!hash.containsKey(annotationName)) {
					list = new Vector();
					hash.put(annotationName, list);
				}
				list = (Vector) hash.get(annotationName);
				list.add(annotationValue);
			} // for i

			return hash;

		} // extractAnnotationsFromSelection
		// ----------------------------------------------------------------------------------------
	} // inner class SelectNodesTreeSelectionListener




}

