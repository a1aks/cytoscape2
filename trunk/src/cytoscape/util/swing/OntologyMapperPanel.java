package cytoscape.util.swing;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.JTree;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import cytoscape.CyNetwork;
import cytoscape.CyNode;
import cytoscape.Cytoscape;
import cytoscape.CytoscapeInit;
import cytoscape.data.CyAttributes;
import cytoscape.data.Semantics;
import cytoscape.data.annotation.Annotation;
import cytoscape.data.annotation.AnnotationDescription;
import cytoscape.data.servers.BioDataServer;
import cytoscape.view.CyNetworkView;

/*
 * OntologyMapperDialog.java
 * 
 * Created on 2006/04/11, 9:57
 * 
 * This code is created by Netbeans 5 w/Swing-Layout + Eclipse 3.1.
 * Swing-Layout class will be standard in Java Standard Edition 6.
 *
 * @author kono
 */
public class OntologyMapperPanel extends JDialog {

	private static final String defaultOboSource = "http://www.geneontology.org/ontology/gene_ontology.obo";

	protected BioDataServer dataServer;
	protected String defaultSpecies;

	private AnnotationDescription[] annotationDescriptions;
	private TreePath annotationPath;
	private String currentAnnotationCategory;

	private HashMap appliedOntologies;

	private CyNetworkView networkView;
	private CyNetwork network;

	public OntologyMapperPanel() {
		initDataStructures();
		initComponents();
	}

	private void initDataStructures() {

		appliedOntologies = new HashMap();

		networkView = Cytoscape.getCurrentNetworkView();
		network = networkView.getNetwork();
		dataServer = Cytoscape.getBioDataServer();

		annotationDescriptions = dataServer.getAnnotationDescriptions();
		Semantics.applyNamingServices(network);
		// defaultSpecies = CytoscapeInit.getDefaultSpeciesName();
		defaultSpecies = CytoscapeInit.getProperty("defaultSpeciesName");
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed" desc=" Generated Code ">
	private void initComponents() {
		goServerScrollPane = new javax.swing.JScrollPane();
		goServerTree = new javax.swing.JTree();
		goAttributeScrollPane = new javax.swing.JScrollPane();
		goAttributeTree = new javax.swing.JTree();
		buttonPanel = new javax.swing.JPanel();
		applyButton = new javax.swing.JButton();
		removeButton = new javax.swing.JButton();
		applyAllButton = new javax.swing.JButton();
		removeAllButton = new javax.swing.JButton();
		layoutButton = new javax.swing.JButton();
		addEdgesButton = new javax.swing.JButton();
		deleteCreatedButton = new javax.swing.JButton();
		okButton = new javax.swing.JButton();
		jScrollPane3 = new javax.swing.JScrollPane();
		jList1 = new javax.swing.JList();

		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
		setTitle("Ontology Mapper");
		goServerScrollPane.setBorder(javax.swing.BorderFactory
				.createTitledBorder(null, "Onyologies in Local GO Server",
						javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
						javax.swing.border.TitledBorder.DEFAULT_POSITION,
						new java.awt.Font("Serif", 1, 12)));

		goServerTree = this.createAvailableAnnotationsTree();
		goServerTree
				.addTreeSelectionListener(new AddAnnotationTreeSelectionListener());

		goServerScrollPane.setViewportView(goServerTree);

		goAttributeTree = this.createNodeSelectionTree();
		goAttributeScrollPane.setBorder(javax.swing.BorderFactory
				.createTitledBorder(null, "GO Data as Attributes",
						javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
						javax.swing.border.TitledBorder.DEFAULT_POSITION,
						new java.awt.Font("Serif", 1, 12)));
		goAttributeScrollPane.setViewportView(goAttributeTree);

		applyButton.setFont(new java.awt.Font("Serif", 1, 12));
		applyButton.setText(">>");
		applyButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				applyButtonActionPerformed(evt);
			}
		});

		removeButton.setFont(new java.awt.Font("Serif", 1, 12));
		removeButton.setText("<<");
		removeButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				removeButtonActionPerformed(evt);
			}
		});

		applyAllButton.setText("Applly All");

		removeAllButton.setText("Remove All");

		layoutButton.setText("Layout");

		addEdgesButton.setText("Add Edges");

		deleteCreatedButton.setText("Delete Created");

		okButton.setText("OK");
		okButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				okButtonActionPerformed(evt);
			}
		});

		org.jdesktop.layout.GroupLayout buttonPanelLayout = new org.jdesktop.layout.GroupLayout(
				buttonPanel);
		buttonPanel.setLayout(buttonPanelLayout);
		buttonPanelLayout
				.setHorizontalGroup(buttonPanelLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								buttonPanelLayout
										.createSequentialGroup()
										.add(
												buttonPanelLayout
														.createParallelGroup(
																org.jdesktop.layout.GroupLayout.LEADING)
														.add(
																buttonPanelLayout
																		.createSequentialGroup()
																		.addContainerGap()
																		.add(
																				buttonPanelLayout
																						.createParallelGroup(
																								org.jdesktop.layout.GroupLayout.LEADING)
																						.add(
																								org.jdesktop.layout.GroupLayout.TRAILING,
																								applyButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)
																						.add(
																								org.jdesktop.layout.GroupLayout.TRAILING,
																								removeButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)
																						.add(
																								org.jdesktop.layout.GroupLayout.TRAILING,
																								applyAllButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)
																						.add(
																								addEdgesButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)
																						.add(
																								deleteCreatedButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								Short.MAX_VALUE)
																						.add(
																								org.jdesktop.layout.GroupLayout.TRAILING,
																								layoutButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)
																						.add(
																								org.jdesktop.layout.GroupLayout.TRAILING,
																								removeAllButton,
																								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
																								120,
																								Short.MAX_VALUE)))
														.add(
																buttonPanelLayout
																		.createSequentialGroup()
																		.add(
																				45,
																				45,
																				45)
																		.add(
																				okButton)))
										.addContainerGap()));
		buttonPanelLayout
				.setVerticalGroup(buttonPanelLayout
						.createParallelGroup(
								org.jdesktop.layout.GroupLayout.LEADING)
						.add(
								buttonPanelLayout
										.createSequentialGroup()
										.addContainerGap()
										.add(applyButton)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED)
										.add(removeButton)
										.add(21, 21, 21)
										.add(applyAllButton)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED)
										.add(removeAllButton)
										.add(34, 34, 34)
										.add(layoutButton)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED)
										.add(addEdgesButton)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED)
										.add(deleteCreatedButton)
										.addPreferredGap(
												org.jdesktop.layout.LayoutStyle.RELATED,
												32, Short.MAX_VALUE).add(
												okButton)));

		jScrollPane3.setViewportView(jList1);

		org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(
				getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(
				org.jdesktop.layout.GroupLayout.TRAILING,
				layout.createSequentialGroup().addContainerGap().add(
						jScrollPane3,
						org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 178,
						org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.addPreferredGap(
								org.jdesktop.layout.LayoutStyle.RELATED).add(
								goServerScrollPane,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								215, Short.MAX_VALUE).addPreferredGap(
								org.jdesktop.layout.LayoutStyle.RELATED).add(
								buttonPanel,
								org.jdesktop.layout.GroupLayout.PREFERRED_SIZE,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
						.addPreferredGap(
								org.jdesktop.layout.LayoutStyle.RELATED).add(
								goAttributeScrollPane,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								224, Short.MAX_VALUE).addContainerGap()));
		layout.setVerticalGroup(layout.createParallelGroup(
				org.jdesktop.layout.GroupLayout.LEADING).add(
				org.jdesktop.layout.GroupLayout.TRAILING,
				layout.createSequentialGroup().addContainerGap().add(
						layout.createParallelGroup(
								org.jdesktop.layout.GroupLayout.TRAILING).add(
								goAttributeScrollPane,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								327, Short.MAX_VALUE).add(goServerScrollPane,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								327, Short.MAX_VALUE).add(
								org.jdesktop.layout.GroupLayout.LEADING,
								jScrollPane3,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								327, Short.MAX_VALUE).add(buttonPanel,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								org.jdesktop.layout.GroupLayout.DEFAULT_SIZE,
								Short.MAX_VALUE)).addContainerGap()));
		pack();
	}// </editor-fold>

	private void removeButtonActionPerformed(java.awt.event.ActionEvent evt) {
		// TODO add your handling code here:
	}

	/*
	 * This method will be called by Apply Button ( >> ).
	 */
	private void applyButtonActionPerformed(java.awt.event.ActionEvent evt) {

		// int max = annotationPath.getPathCount();

		// for (int i = 0; i < max; i++) {
		// DefaultMutableTreeNode node = (DefaultMutableTreeNode) annotationPath
		// .getPathComponent(i);
		// }

		DefaultMutableTreeNode node1 = (DefaultMutableTreeNode) annotationPath
				.getPathComponent(1);
		AnnotationDescription aDesc = (AnnotationDescription) node1
				.getUserObject();
		DefaultMutableTreeNode node2 = (DefaultMutableTreeNode) annotationPath
				.getPathComponent(2);

		int level = ((Integer) node2.getUserObject()).intValue();
		if (aDesc == null)
			return;

		currentAnnotationCategory = addAnnotationToNodes(aDesc, level);

		Object[] uniqueAnnotationValues = null;

		CyAttributes nodeAtts = Cytoscape.getNodeAttributes();
		Iterator it = Cytoscape.getRootGraph().nodesIterator();
		HashSet values = new HashSet();
		while (it.hasNext()) {
			CyNode node = (CyNode) it.next();
			byte type = nodeAtts.getType(currentAnnotationCategory);
			if (type == CyAttributes.TYPE_STRING) {
				String strVal = nodeAtts.getStringAttribute(node
						.getIdentifier(), currentAnnotationCategory);
				if (strVal != null)
					values.add(strVal);
			} else if (type == CyAttributes.TYPE_SIMPLE_LIST) {
				List vals = nodeAtts.getAttributeList(node.getIdentifier(),
						currentAnnotationCategory);
				if (vals.size() > 0) {
					Object val = vals.get(0);
					if (val instanceof String)
						values.addAll(vals);
				}
			}

		}// while it.hasNext

		uniqueAnnotationValues = values.toArray();

		if (uniqueAnnotationValues.length == 0) {
			// System.err.println( "No match exception" + e1 );
			JOptionPane
					.showMessageDialog(
							null,
							"There is no match between the selected annotation \n"
									+ "and current nodes in the network.\n"
									+ "\nMake sure that your network data file \n"
									+ "and Gene Association files use same naming scheme.\n\n"
									+ "Please compare the 3rd column of Gene Association\n"
									+ "file (DB_Object_Symbol) and node names in your network.",
							"No match in Gene Ontology Database",
							JOptionPane.ERROR_MESSAGE);

		} // Mod by kono end (10/20/2005)

		if (uniqueAnnotationValues != null && uniqueAnnotationValues.length > 0
				&& uniqueAnnotationValues[0].getClass() == String.class) {
			java.util.Arrays.sort(uniqueAnnotationValues,
					(Comparator) String.CASE_INSENSITIVE_ORDER);
			appendToSelectionTree(currentAnnotationCategory,
					uniqueAnnotationValues);
		}
	}

	protected void appendToSelectionTree(String currentAnnotationCategory,
			Object[] uniqueAnnotationValues) {
		DefaultMutableTreeNode branch = new DefaultMutableTreeNode(
				currentAnnotationCategory);

		for (int i = 0; i < uniqueAnnotationValues.length; i++)
			branch.add(new DefaultMutableTreeNode(uniqueAnnotationValues[i]));

		DefaultMutableTreeNode root = (DefaultMutableTreeNode) goAttributeTree
				.getModel().getRoot();
		DefaultTreeModel model = (DefaultTreeModel) goAttributeTree.getModel();
		model.insertNodeInto(branch, root, root.getChildCount());
		goAttributeTree.scrollPathToVisible(new TreePath(branch.getPath()));
		model.reload();

	} // appendToSelectionTree

	private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {
		// TODO add your handling code here:
		this.dispose();
	}

	// Variables declaration - do not modify
	private javax.swing.JButton addEdgesButton;
	private javax.swing.JButton applyAllButton;
	private javax.swing.JButton applyButton;
	private javax.swing.JPanel buttonPanel;
	private javax.swing.JButton deleteCreatedButton;
	private javax.swing.JScrollPane goAttributeScrollPane;
	private javax.swing.JTree goAttributeTree;
	private javax.swing.JScrollPane goServerScrollPane;
	private javax.swing.JTree goServerTree;
	private javax.swing.JList jList1;
	private javax.swing.JScrollPane jScrollPane3;
	private javax.swing.JButton layoutButton;
	private javax.swing.JButton okButton;
	private javax.swing.JButton removeAllButton;
	private javax.swing.JButton removeButton;

	// End of variables declaration

	/*
	 * Build GO Server Tree
	 * 
	 * This tree is based on data in BioDataServer Object.
	 * 
	 */
	protected JTree createAvailableAnnotationsTree() {
		DefaultMutableTreeNode root = new DefaultMutableTreeNode(
				"Available Annotations");
		createTreeNodes(root, annotationDescriptions);
		JTree tree = new JTree(root);
		tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setRootVisible(false);
		tree.setShowsRootHandles(true);
		// expandAll (tree, new TreePath (root), true);
		return tree;
	}

	protected void createTreeNodes(DefaultMutableTreeNode root,
			AnnotationDescription[] descriptions)
	// for each of the descriptions, and only if the description is of a
	// species in the
	// current graph: create a 'topLevelName' which will be the branch of
	// the JTree,
	// and a set of leaves for each logical level in that description's
	// ontology
	{
		if (descriptions == null || descriptions.length == 0)
			return;

		// Extract species name in the network.
		Set speciesInGraph = Semantics.getSpeciesInNetwork(network);

		DefaultMutableTreeNode branch = null;
		Vector topLevelNamesList = new Vector();

		for (int i = 0; i < descriptions.length; i++) {
			String species = descriptions[i].getSpecies();
			if (!speciesInGraph.contains(species)) {
				continue;
			}
			topLevelNamesList.add(descriptions[i].getCurator() + ", "
					+ descriptions[i].getType() + ", "
					+ descriptions[i].getSpecies());
			branch = new DefaultMutableTreeNode(descriptions[i]);

			// Extract annotation from
			Annotation annotation = dataServer.getAnnotation(descriptions[i]);

			if (annotation == null) {
				continue;
			}
			int maxDepth = annotation.maxDepth();
			for (int level = 0; level < maxDepth; level++)
				branch.add(new DefaultMutableTreeNode(new Integer(level + 1)));
			root.add(branch);
		}

	} // createTreeNodes

	protected JTree createNodeSelectionTree() {
		DefaultMutableTreeNode root = new DefaultMutableTreeNode(
				"Annotations Categories");
		JTree tree = new JTree(root);
		// tree.getSelectionModel().setSelectionMode
		// (TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setRootVisible(false);
		tree.setShowsRootHandles(true);
		expandAll(tree, new TreePath(root), true);
		return tree;

	} // createNodeSelectionTree

	private void expandAll(JTree tree, TreePath parent, boolean expand) {
		TreeNode node = (TreeNode) parent.getLastPathComponent();
		if (node.getChildCount() >= 0) {
			for (Enumeration e = node.children(); e.hasMoreElements();) {
				TreeNode n = (TreeNode) e.nextElement();
				TreePath path = parent.pathByAddingChild(n);
				expandAll(tree, path, expand);
			} // for
		} // if

		if (expand)
			tree.expandPath(parent);
		else
			tree.collapsePath(parent);

	} // expandAll

	/*
	 * Methods called by actions
	 * 
	 */

	/*
	 * Map BDS object to CyAttributes. TODO: Support Synonym
	 * 
	 */
	public String addAnnotationToNodes(AnnotationDescription aDesc, int level) {

		CyAttributes nodeAttributes = Cytoscape.getNodeAttributes();

		// something like "GO biological process" or "KEGG metabolic pathway"
		String baseAnnotationName = aDesc.getCurator() + " " + aDesc.getType();
		String annotationNameAtLevel = baseAnnotationName + " (Level " + level
				+ ")";
		String annotationNameForLeafIDs = baseAnnotationName + " leaf IDs";

		// This is necessary since Thesaurus needs species name.
		String species = aDesc.getSpecies();

		// make a fresh start
		nodeAttributes.deleteAttribute(annotationNameAtLevel);
		nodeAttributes.deleteAttribute(annotationNameForLeafIDs);

		Iterator it = Cytoscape.getRootGraph().nodesIterator();
		ArrayList canonicals = new ArrayList();
		while (it.hasNext()) {
			CyNode node = (CyNode) it.next();
			String canonical = nodeAttributes.getStringAttribute(node
					.getIdentifier(), Semantics.CANONICAL_NAME);
			if (canonical != null)
				canonicals.add(canonical);
		}

		String[] canonicalNodeNames = (String[]) canonicals
				.toArray(new String[canonicals.size()]);

		int unAnnotatedNodeCount = 0;
		for (int i = 0; i < canonicalNodeNames.length; i++) {
			String[][] fullAnnotations = dataServer.getAllAnnotations(aDesc,
					canonicalNodeNames[i]);
			if (fullAnnotations.length == 0)
				unAnnotatedNodeCount++;
			else {
				String[] uniqueAnnotationsAtLevel = collapseToUniqueAnnotationsAtLevel(
						fullAnnotations, level);

				// List to save values in the current level
				List annotsList = new ArrayList();
				if (uniqueAnnotationsAtLevel.length == 0) {
					// No attribute available for this node
					nodeAttributes.setAttribute(canonicalNodeNames[i],
							annotationNameAtLevel, "");
				} else {
					// Extract all values in the current level
					for (int j = 0; j < uniqueAnnotationsAtLevel.length; j++) {

						System.out.println("node cn = " + canonicalNodeNames[i]
								+ ", and an@level = " + annotationNameAtLevel);

						String[] syno = dataServer.getAllCommonNames(species,
								canonicalNodeNames[i]);

						for (int idx = 0; idx < syno.length; idx++) {
							System.out.println("Syno = " + syno[idx]);
						}

						// System.out.println(", an value@level = "
						// + uniqueAnnotationsAtLevel[j]);

						// we can do this because at the begining of the method
						// we deleted the attribute annotationNameAtLevel:
						annotsList = nodeAttributes.getAttributeList(
								canonicalNodeNames[i], annotationNameAtLevel);

						// annotsList = nodeAttributes.getAttributeList(
						// canonicalNodeNames[i], annotationNameAtLevel);

						if (annotsList == null) {
							annotsList = new ArrayList();
							nodeAttributes.setAttributeList(
									canonicalNodeNames[i],
									annotationNameAtLevel, annotsList);
							annotsList.add(uniqueAnnotationsAtLevel[j]);
						}
						annotsList.add(uniqueAnnotationsAtLevel[j]);

					}// for j

					if (annotsList.size() != 0) {
						nodeAttributes.setAttributeList(canonicalNodeNames[i],
								annotationNameAtLevel, annotsList);
					}
				}

				int[] annotationIDs = dataServer.getClassifications(aDesc,
						canonicalNodeNames[i]);
				Integer[] integerArray = new Integer[annotationIDs.length];
				for (int j = 0; j < annotationIDs.length; j++)
					integerArray[j] = new Integer(annotationIDs[j]);
			} // else: this node is annotated
		} // for i

		return annotationNameAtLevel;

	} // addAnnotationToNodes

	/**
	 * return only the unique categories (typically representing gene
	 * annotations) which exist at the specified level. genes (for example) may
	 * be annotated as belonging to two or more different categories, but at a
	 * higher logical level, these different categories may merge. for example,
	 * the halobacterium gene VNG0623G is classified by KEGG, in its 3-level
	 * ontology as belonging to two categories at the most specific (third)
	 * level
	 * <ol>
	 * <li> Valine, leucine and isoleucine degradation
	 * <li> Propanoate metabolism
	 * <ol>
	 * At level two, the annotation is:
	 * <ol>
	 * <li> Amino Acid Metabolism
	 * <li> Carbohydrate Metabolism
	 * <ol>
	 * At level one, the annotation is simply
	 * <ol>
	 * <li>Metabolism
	 * <ol>
	 * This method calculates and returns the unique annotations for a
	 * biological entity at the specified level.
	 */
	private String[] collapseToUniqueAnnotationsAtLevel(
			String[][] fullAnnotations, int level) {
		Vector collector = new Vector();

		for (int i = 0; i < fullAnnotations.length; i++) {
			int indexOfClosestAvailableLevel = level - 1;
			if (indexOfClosestAvailableLevel > (fullAnnotations[i].length - 1))
				indexOfClosestAvailableLevel = fullAnnotations[i].length - 1;
			String annotationAtLevel = fullAnnotations[i][indexOfClosestAvailableLevel];
			if (!collector.contains(annotationAtLevel))
				collector.add(annotationAtLevel);
		} // for i

		return (String[]) collector.toArray(new String[0]);

	} // collapseToUniqueAnnotationsAtLevel

	class AddAnnotationTreeSelectionListener implements TreeSelectionListener {

		public void valueChanged(TreeSelectionEvent e) {

			System.out.println("TREE!! ");

			DefaultMutableTreeNode node = (DefaultMutableTreeNode) goServerTree
					.getLastSelectedPathComponent();
			if (node == null)
				return;
			if (!node.isLeaf())
				return;

			System.out.println("Path = ! ");
			annotationPath = goServerTree.getSelectionPaths()[0];
			// annotateNodesButton.setEnabled(true);
		}

	} // 

}
