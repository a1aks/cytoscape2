
/*
 Copyright (c) 2006, 2007, The Cytoscape Consortium (www.cytoscape.org)

 The Cytoscape Consortium is:
 - Institute for Systems Biology
 - University of California San Diego
 - Memorial Sloan-Kettering Cancer Center
 - Institut Pasteur
 - Agilent Technologies

 This library is free software; you can redistribute it and/or modify it
 under the terms of the GNU Lesser General Public License as published
 by the Free Software Foundation; either version 2.1 of the License, or
 any later version.

 This library is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY, WITHOUT EVEN THE IMPLIED WARRANTY OF
 MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  The software and
 documentation provided hereunder is on an "as is" basis, and the
 Institute for Systems Biology and the Whitehead Institute
 have no obligations to provide maintenance, support,
 updates, enhancements or modifications.  In no event shall the
 Institute for Systems Biology and the Whitehead Institute
 be liable to any party for direct, indirect, special,
 incidental or consequential damages, including lost profits, arising
 out of the use of this software and its documentation, even if the
 Institute for Systems Biology and the Whitehead Institute
 have been advised of the possibility of such damage.  See
 the GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with this library; if not, write to the Free Software Foundation,
 Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
*/

package cytoscape;

import cytoscape.RootGraph;


/**
 * This class defines static methods that provide new instances
 * of cytoscape.RootGraph objects.
 */
public final class FingRootGraphFactory {
	// "No constructor".
	private FingRootGraphFactory() {
	}

	/**
	 * Returns a new instance of cytoscape.RootGraph.  Obviously, a new
	 * RootGraph instance contains no nodes or edges.<p>
	 * A secret feature is that the returned object not only implements
	 * RootGraph - it also implements cytoscape.graph.dynamic.DynamicGraph.
	 * In other words, you can cast the return value to DynamicGraph.  The
	 * relationship between RootGraph node/edge indices and DynamicGraph nodes
	 * and edges is they are complements of each other.  Complement is '~' in
	 * Java.<p>
	 * In addition to the RootGraph secretly implementing DyanmicGraph,
	 * all of the GraphPerspective objects generated by the returned RootGraph
	 * secretly implement cytoscape.graph.fixed.FixedGraph.  In other words,
	 * all GraphPerspective objects that are part of this RootGraph system
	 * can be cast to FixedGraph.  The relationship between GraphPerspective
	 * node/edge indices (which are identical to RootGraph indices) and
	 * FixedGraph nodes and edges is they are complements of each other.<p>
	 * Below are time complexities of methods implemented:
	 * <blockquote><table border=1 cellspacing=0 cellpadding=5>
	 * <tr><th colspan=2>RootGraph</th></tr>
	 * <tr><th>method</th><th>time complexity</th></tr>
	 * <tr>
	 * <td>createGraphPerspective(Node[], Edge[])</td>
	 * <td>A GraphPerspective is created in O(N + E) time, where N is the
	 *     length of the Node input array and E is the length of the Edge
	 *     input array.</td>
	 * </tr><tr>
	 * <td>createGraphPerspective(int[], int[])</td>
	 * <td>A GraphPerspective is created in O(N + E) time, where N is the
	 *     length of the first input int array and E is the length of the
	 *     second input int array.</td>
	 * </tr><tr>
	 * <td>ensureCapacity(int, int)</td>
	 * <td>This method returns in constant time.</td>
	 * </tr><tr>
	 * <td>getNodeCount()</td>
	 * <td>The total node count is calculated in constant time.</td>
	 * </tr><tr>
	 * <td>getEdgeCount()</td>
	 * <td>The total edge count is calculated in constant time.</td>
	 * </tr><tr>
	 * <td>nodesIterator()</td>
	 * <td>An Iterator is returned in constant time.  Each successive element
	 *     in the iteration is returned in constant time.</td>
	 * </tr><tr>
	 * <td>nodesList()</td>
	 * <td>A List of Node objects is returned in O(N) time, where N is the
	 *     number of nodes in this RootGraph.</td>
	 * </tr><tr>
	 * <td>getNodeIndicesArray()</td>
	 * <td>An array of node indices is returned in O(N) time, where N is the
	 *     number of nodes in this RootGraph.</td>
	 * </tr><tr>
	 * <td>edgesIterator()</td>
	 * <td>An iterator is returned in constant time.  Each successive element
	 *     in the iteration is returned in constant time.</td>
	 * </tr><tr>
	 * <td>edgesList()</td>
	 * <td>A List of Edge objects is returned in O(E) time, where E is the
	 *     number of edges in this RootGraph.</td>
	 * </tr><tr>
	 * <td>getEdgeIndicesArray()</td>
	 * <td>An array of edge indices is returned in O(E) time, where E is the
	 *     number of edges in this RootGraph.</td>
	 * </tr><tr>
	 * <td>removeNode(Node)</td>
	 * <td>Essentially, the operation of removing a node takes O(E) time where
	 *     E is the number of edges touching the node being removed.  However,
	 *     this is no longer an absolute truth once many GraphPerspective
	 *     objects are created from this RootGraph, or many meta-node
	 *     relationships are created which involve the node being removed.</td>
	 * </tr><tr>
	 * <td>removeNode(int)</td>
	 * <td>Essentially, the operation of removing a node takes O(E) time where
	 *     E is the number of edges touching the node being removed.  However,
	 *     this is no longer an absolute truth once many GraphPerspective
	 *     objects are created from this RootGraph, or many meta-node
	 *     relationships are created which involve the node being removed.</td>
	 * </tr><tr>
	 * <td>removeNodes(List)</td>
	 * <td>Essentially, the operation of removing a node takes O(E) time where
	 *     E is the number of edges touching the node being removed.  However,
	 *     this is no longer an absolute truth once many GraphPerspective
	 *     objects are created from this RootGraph, or many meta-node
	 *     relationships are created which involve the node being removed.
	 *     This method removes each node in succession.</td>
	 * </tr><tr>
	 * <td>removeNodes(int[])</td>
	 * <td>Essentially, the operation of removing a node takes O(E) time where
	 *     E is the number of edges touching the node being removed.  However,
	 *     this is no longer an absolute truth once many GraphPerspective
	 *     objects are created from this RootGraph, or many meta-node
	 *     relationships are created which involve the node being removed.
	 *     This method removes each node in succession.</td>
	 * </tr><tr>
	 * <td>createNode()</td>
	 * <td>A node is created in constant time.</td>
	 * </tr><tr>
	 * <td>createNode(Node[], Edge[])</td>
	 * <td>This meta-node operation takes O(N + E) time, where N is the
	 *     length of the input Node array and E is the length of the input
	 *     Edge array.</td>
	 * </tr><tr>
	 * <td>createNode(GraphPerspective)</td>
	 * <td>This meta-node operation takes O(N + E) time, where N is the
	 *     number of nodes in specified GraphPerspective and E is the
	 *     number of edges in specified GraphPerspective.</td>
	 * </tr><tr>
	 * <td>createNode(int[], int[])</td>
	 * <td>This meta-node operation takes O(N + E) time, where N is the
	 *     length of the first input int array and E is the length of the
	 *     second input int array.</td>
	 * </tr><tr>
	 * <td>createNodes(int)</td>
	 * <td>A node is created in constant time.  This method creates the
	 *     specified number of nodes in succession.</td>
	 * </tr><tr>
	 * <td>removeEdge(Edge)</td>
	 * <td>Essentially, the operation of removing an edge takes constant time.
	 *     However, this is no longer an absolute truth once many
	 *     GraphPerspective objects are created from this RootGraph, or many
	 *     meta-node relationships are created which involve the edge being
	 *     removed.</td>
	 * </tr><tr>
	 * <td>removeEdge(int)</td>
	 * <td>Essentially, the operation of removing an edge takes constant time.
	 *     However, this is no longer an absolute truth once many
	 *     GraphPerspective objects are created from this RootGraph, or many
	 *     meta-node relationships are created which involve the edge being
	 *     removed.</td>
	 * </tr><tr>
	 * <td>removeEdges(List)</td>
	 * <td>Essentially, the operation of removing an edge takes constant time.
	 *     However, this is no longer an absolute truth once many
	 *     GraphPerspective objects are created from this RootGraph, or many
	 *     meta-node relationships are created which involve the edge being
	 *     removed.  This removes each edge successively.</td>
	 * </tr><tr>
	 * <td>removeEdges(int[])</td>
	 * <td>Essentially, the operation of removing an edge takes constant time.
	 *     However, this is no longer an absolute truth once many
	 *     GraphPerspective objects are created from this RootGraph, or many
	 *     meta-node relationships are created which involve the edge being
	 *     removed.  This removes each edge successively.</td>
	 * </tr><tr>
	 * <td>createEdge(Node, Node)</td>
	 * <td>The operation of creating an edge is performed in constant time.</td>
	 * </tr><tr>
	 * <td>createEdge(Node, Node, boolean)</td>
	 * <td>The operation of creating an edge is performed in constant time.</td>
	 * </tr><tr>
	 * <td>createEdge(int, int)</td>
	 * <td>The operation of creating an edge is performed in constant time.</td>
	 * </tr><tr>
	 * <td>createEdge(int, int, boolean)</td>
	 * <td>The operation of creating an edge is performed in constant time.</td>
	 * </tr><tr>
	 * <td>createEdges(int[], int[], boolean)</td>
	 * <td>The operation of creating an edge is performed in constant time.
	 *     This creates each edge in succession.</td>
	 * </tr><tr>
	 * <td>containsNode(Node)</td>
	 * <td>Determining whether or not a node is in a RootGraph takes
	 *     constant time.</td>
	 * </tr><tr>
	 * <td>containsEdge(Edge)</td>
	 * <td>Determining whether or not an edge is in a RootGraph takes
	 *     constant time.</td>
	 * </tr><tr>
	 * <td>neighborsList(Node)</td>
	 * <td>Node neighbors are calculated on O(E) time, where E is the number of
	 *     edges touching the node whose neighbors we're calculating.</td>
	 * </tr><tr>
	 * <td>isNeighbor(Node, Node)</td>
	 * <td>The operation of determining whether or not two nodes are
	 *     neighbors has time complexity O(min(E, F)), where E is the number of
	 *     edges touching one node and F is the number of edges touching the
	 *     other node (this is actually over-simplified and more pessimistic
	 *     than it could be).</td>
	 * </tr><tr>
	 * <td>isNeighbor(int, int)</td>
	 * <td>The operation of determining whether or not two nodes are
	 *     neighbors has time complexity O(min(E, F)), where E is the number of
	 *     edges touching one node and F is the number of edges touching the
	 *     other node (this is actually over-simplified and more pessimistic
	 *     than it could be).</td>
	 * </tr><tr>
	 * <td>edgeExists(Node, Node)</td>
	 * <td>The operation of determining whether or not an edge exists starting
	 *     at one [specified] node and ending at another [specified] node
	 *     has time complexity O(min(E, F)), where E is the number of
	 *     edges touching one node and F is the number of edges touching the
	 *     other node (this is actually over-simplified and more pessimistic
	 *     than it could be).</td>
	 * </tr><tr>
	 * <td>edgeExists(int, int)</td>
	 * <td>The operation of determining whether or not an edge exists starting
	 *     at one [specified] node and ending at another [specified] node
	 *     has time complexity O(min(E, F)), where E is the number of
	 *     edges touching one node and F is the number of edges touching the
	 *     other node (this is actually over-simplified and more pessimistic
	 *     than it could be).</td>
	 * </tr><tr>
	 * <td>getEdgeCount(Node, Node, boolean)</td>
	 * <td>The operation of determining the number of existig edges starting at
	 *     one [specified] node and ending at another [specified] node has
	 *     time complexity O(min(E, F)), where E is the number of edges touching
	 *     one node and F is the number of edges touching the other node.</td>
	 * </tr><tr>
	 * <td>getEdgeCount(int, int, boolean)</td>
	 * <td>The operation of determining the number of existing edges starting at
	 *     one [specified] node and ending at another [specified] node has
	 *     time complexity O(min(E, F)), where E is the number of edges touching
	 *     one node and F is the number of edges touching the other node.</td>
	 * </tr><tr>
	 * <td>getAdjacentEdgeIndicesArray(int, boolean, boolean, boolean)</td>
	 * <td>The operation of getting edges adjacent to a node, fitting
	 *     defined characteristics (specified by three boolean values) has
	 *     time complexity O(E), where E is the total number of edges touching
	 *     the node in question.</td>
	 * </tr><tr>
	 * <td>getConnectingEdgeIndicesArray(int[])</td>
	 * <td>Computing a "connecting web" of edges from a list of input nodes
	 *     has time complexity O(E), where E is the number of edges touching
	 *     at least one node in the input set of nodes.</td>
	 * </tr><tr>
	 * <td>getConnectingNodeIndicesArray(int[])</td>
	 * <td>This method has time complexity O(E), where E is the length
	 *     of the input array.</td>
	 * </tr><tr>
	 * <td>getEdgeIndicesArray(int, int, boolean, boolean)</td>
	 * <td>The operation of finding all edges [meeting certain criteria,
	 *     specified by two boolean input parameters] starting at one [specified]
	 *     node and ending at another [specified] node has time complexity
	 *     O(min(E, F)), where E is the total number of edges touching the
	 *     start node and F is the total number of edges touching the end
	 *     node.</td>
	 * </tr><tr>
	 * <td>edgesList(Node, Node)</td>
	 * <td>The operation of finding all edges starting at one [specified]
	 *     node and ending at another [specified] node has time complexity
	 *     O(min(E, F)), where E is the total number of edges touching the
	 *     start node and F is the total number of edges touching the end
	 *     node.</td>
	 * </tr><tr>
	 * <td>edgesList(int, int, boolean)</td>
	 * <td>The operation of finding all edges starting at one [specified]
	 *     node and ending at another [specified] node has time complexity
	 *     O(min(E, F)), where E is the total number of edges touching the
	 *     start node and F is the total number of edges touching the end
	 *     node.</td>
	 * </tr><tr>
	 * <td>getEdgeIndicesArray(int, int, boolean)</td>
	 * <td>The operation of finding all edges starting at one [specified]
	 *     node and ending at another [specified] node has time complexity
	 *     O(min(E, F)), where E is the total number of edges touching the
	 *     start node and F is the total number of edges touching the end
	 *     node.</td>
	 * </tr><tr>
	 * <td>getInDegree(int)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getInDegree(Node, boolean)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getInDegree(int, boolean)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getOutDegree(Node)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getOutDegree(int)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getOutDegree(Node, boolean)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getOutDegree(int, boolean)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getDegree(Node)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getDegree(int)</td>
	 * <td>All degree-computing methods are executed in constant time.</td>
	 * </tr><tr>
	 * <td>getIndex(Node)</td>
	 * <td>The index of a node is computed in constant time.</td>
	 * </tr><tr>
	 * <td>getNode(int)</td>
	 * <td>A node is retrieved in constant time.</td>
	 * </tr><tr>
	 * <td>getIndex(Edge)</td>
	 * <td>The index of an edge is computed in constant time.</td>
	 * </tr><tr>
	 * <td>getEdge(int)</td>
	 * <td>An edge is retrieved in constant time.</td>
	 * </tr><tr>
	 * <td>getEdgeSourceIndex(int)</td>
	 * <td>The source node of an edge is determined in constant time.</td>
	 * </tr><tr>
	 * <td>getEdgeTargetIndex(int)</td>
	 * <td>The target node of an edge is determined in constant time.</td>
	 * </tr><tr>
	 * <td>isEdgeDirected(int)</td>
	 * <td>The directedness of an edge is determined in constant time.</td>
	 * </tr><tr>
	 * <td>addMetaChild(Node, Node)</td>
	 * <td>Adding a node->node meta-relationship has time complexity
	 *     O(min(P, C)), where P is the number of pre-existing children the
	 *     soon-to-be parent has, and C is the number of pre-existing parents
	 *     the soon-to-be child has.</td>
	 * </tr><tr>
	 * <td>addNodeMetaChild(int, int)</td>
	 * <td>Adding a node->node meta-relationship has time complexity
	 *     O(min(P, C)), where P is the number of pre-existing children the
	 *     soon-to-be parent has, and C is the number of pre-existing parents
	 *     the soon-to-be child has.</td>
	 * </tr><tr>
	 * <td>removeNodeMetaChild(int, int)</td>
	 * <td>Grrr.  This is complicated.  In the simplest case (and in the
	 *     case that will occur frequently), this is much like removing
	 *     a node from a graph -- the time complexity is O(E), where E is the
	 *     number of edges touching the child node.</td>
	 * </tr><tr>
	 * <td>isMetaParent(Node, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodeMetaParent(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>metaParentsList(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>nodeMetaParentsList(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getNodeMetaParentIndicesArray(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isMetaChild(Node, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodeMetaChild(int, int)</td>
	 * <td>The operation of determining whether or not a given node is the
	 *     meta-parent of another given node has time complexity O(min(P, C)),
	 *     where P is the number of children (both nodes and edges) the potential
	 *     parent has, and C is the number of parents the potential child
	 *     has.</td>
	 * </tr><tr>
	 * <td>isNodeMetaChild(int, int, boolean)</td>
	 * <td>The recursive version of this method does a depth-first search of
	 *     the meta-graph structure starting at the specified parent node;
	 *     therefore, the time complexity of this recursive operation is
	 *     O(M), where M is the size of set (including both nodes and edges)
	 *     "reachable" by following meta-paths from parent to child, starting
	 *     at specified parent node.</td>
	 * </tr><tr>
	 * <td>nodeMetaChildrenList(Node)</td>
	 * <td>The operation of getting all node children of a given parent node
	 *     has time complexity O(C), where C is the number of children of the
	 *     given parent node, including both nodes and edges.</td>
	 * </tr><tr>
	 * <td>nodeMetaChildrenList(int)</td>
	 * <td>The operation of getting all node children of a given parent node
	 *     has time complexity O(C), where C is the number of children of the
	 *     given parent node, including both nodes and edges.</td>
	 * </tr><tr>
	 * <td>getNodeMetaChildIndicesArray(int)</td>
	 * <td>The operation of getting all node children of a given parent node
	 *     has time complexity O(C), where C is the number of children of the
	 *     given parent node, including both nodes and edges.</td>
	 * </tr><tr>
	 * <td>getNodeMetaChildIndicesArray(int, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getChildlessMetaDescendants(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>addMetaChild(Node, Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>addEdgeMetaChild(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>removeEdgeMetaChild(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isMetaParent(Edge, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgeMetaParent(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>metaParentsList(Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeMetaParentsList(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeMetaParentIndicesArray(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isMetaChild(Node, Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgeMetaChild(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeMetaChildrenList(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeMetaChildrenList(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeMetaChildIndicesArray(int)</td>
	 * <td></td>
	 * </tr>
	 * </table><br /><table border=1 cellspacing=0 cellpadding=5>
	 * <tr><th colspan=2>GraphPerspective</th></tr>
	 * <tr><th>method</th><th>time complexity</th></tr>
	 * <tr>
	 * <td>addGraphPerspectiveChangeListener(GraphPerspectiveChangeListener)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>removeGraphPerspectiveChangeListener(GraphPerspectiveChangeListener)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>clone()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRootGraph()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getNodeCount()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeCount()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>nodesIterator()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>nodesList()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getNodeIndicesArray()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgesIterator()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgesList()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeIndicesArray()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeIndicesArray(int, int, boolean, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideNode(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideNode(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideNodes(List)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideNodes(int[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreNode(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreNode(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreNodes(List)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreNodes(List, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreNodes(int[], boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreNodes(int[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideEdge(Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideEdge(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideEdges(List)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>hideEdges(int[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreEdge(Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreEdge(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreEdges(List)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>restoreEdges(int[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>containsNode(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>containsNode(Node, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>containsEdge(Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>containsEdge(Edge, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>join(GraphPerspective)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>createGraphPerspective(Node[], Edge[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>createGraphPerspective(int[], int[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>createGraphPerspective(Filter)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>neighborsList(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>neighborsArray(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNeighbor(Node, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNeighbor(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeExists(Node, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeExists(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeCount(Node, Node, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeCount(int, int, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgesList(Node, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgesList(int, int, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeIndicesArray(int, int, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getInDegree(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getInDegree(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getInDegree(Node, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getInDegree(int, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getOutDegree(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getOutDegree(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getOutDegree(Node, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getOutDegree(int, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getDegree(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getDegree(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getIndex(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getNodeIndex(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRootGraphNodeIndex(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getNode(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getIndex(Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeIndex(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRootGraphEdgeIndex(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdge(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeSourceIndex(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeTargetIndex(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgeDirected(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isMetaParent(Node, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodeMetaParent(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>metaParentsList(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>nodeMetaParentsList(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getNodeMetaParentIndicesArray(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isMetaChild(Node, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodeMetaChild(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>nodeMetaChildrenList(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>nodeMetaChildrenList(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getNodeMetaChildrenIndicesArray(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isMetaParent(Edge, Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgeMetaParent(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>metaParentsList(Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeMetaParentsList(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeMetaParentIndicesArray(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isMetaChild(Node, Edge)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgeMetaChild(int, int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeMetaChildrenList(Node)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>edgeMetaChildrenList(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getEdgeMetaChildIndicesArray(int)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getAdjacentEdgesList(Node, boolean, boolean, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getAdjacentEdgeIndicesArray(int, boolean, boolean, boolean)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getConnectingEdges(List)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getConnectingEdgeIndicesArray(int[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getConnectingNodeIndicesArray(int[])</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>createGraphPerspective(int[])</td>
	 * <td></td>
	 * </tr></table><br /><table border=1 cellspacing=0 cellpadding=5>
	 * <tr><th colspan=2>Node</th></tr>
	 * <tr><th>method</th><th>time complexity</th></tr>
	 * <tr>
	 * <td>getGraphPerspective()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>setGraphPerspective(GraphPerspective)</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRootGraph()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRootGraphIndex()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getIdentifier()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>setIdentifier(String)</td>
	 * <td></td>
	 * </tr></table><br /><table border=1 cellspacing=0 cellpadding=5>
	 * <tr><th colspan=2>Edge</th></tr>
	 * <tr><th>method</th><th>time complexity</th></tr>
	 * <tr>
	 * <td>getSource()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getTarget()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isDirected()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRootGraph()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRootGraphIndex()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getIdentifier()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>setIdentifier(String)</td>
	 * <td></td>
	 * </tr></table><br /><table border=1 cellspacing=0 cellpadding=5>
	 * <tr><th colspan=2>GraphPerspectiveChangeEvent</th></tr>
	 * <tr><th>method</th><th>time complexity</th></tr>
	 * <tr>
	 * <td>getSource()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodesRestoredType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgesRestoredType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodesHiddenType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgesHiddenType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodesSelectedType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isNodesUnselectedType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgesSelectedType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>isEdgesUnselectedType()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRestoredNodes()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRestoredEdges()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getHiddenNodes()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getHiddenEdges()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getSelectedNodes()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getUnselectedNodes()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getSelectedEdges()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getUnselectedEdges()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRestoredNodeIndices()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getRestoredEdgeIndices()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getHiddenNodeIndices()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getHiddenEdgeIndices()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getSelectedNodeIndices()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getUnselectedNodeIndices()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getSelectedEdgeIndices()</td>
	 * <td></td>
	 * </tr><tr>
	 * <td>getUnselectedEdgeIndices()</td>
	 * <td></td>
	 * </tr></table></blockquote>
	 */
	public final static RootGraph instantiateRootGraph() {
		return new FRootGraph();
	}
}
